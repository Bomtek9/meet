(() => {
  "use strict";
  var e = {
      923: () => {
        try {
          self["workbox:core:6.5.4"] && _();
        } catch (e) {}
      },
      190: () => {
        try {
          self["workbox:expiration:6.5.4"] && _();
        } catch (e) {}
      },
      437: () => {
        try {
          self["workbox:precaching:6.5.4"] && _();
        } catch (e) {}
      },
      185: () => {
        try {
          self["workbox:routing:6.5.4"] && _();
        } catch (e) {}
      },
      833: () => {
        try {
          self["workbox:strategies:6.5.4"] && _();
        } catch (e) {}
      },
    },
    t = {};
  function s(n) {
    var a = t[n];
    return (
      void 0 !== a || ((a = t[n] = { exports: {} }), e[n](a, a.exports, s)),
      a.exports
    );
  }
  (() => {
    s(923);
    class t extends Error {
      constructor(t, s) {
        super(
          (function (e) {
            let t = e;
            for (
              var s = arguments.length, n = new Array(1 < s ? s - 1 : 0), a = 1;
              a < s;
              a++
            )
              n[a - 1] = arguments[a];
            return 0 < n.length && (t += " :: ".concat(JSON.stringify(n))), t;
          })(t, s)
        ),
          (this.name = t),
          (this.details = s);
      }
    }
    const n = new Set(),
      a = {
        googleAnalytics: "googleAnalytics",
        precache: "precache-v2",
        prefix: "workbox",
        runtime: "runtime",
        suffix: "undefined" != typeof registration ? registration.scope : "",
      },
      r = (e) =>
        [a.prefix, e, a.suffix].filter((e) => e && 0 < e.length).join("-"),
      i = (e) => e || r(a.precache),
      o = (e) => e || r(a.runtime);
    function c(e, t) {
      var s = new URL(e);
      for (const n of t) s.searchParams.delete(n);
      return s.href;
    }
    let h;
    function l(e) {
      e.then(() => {});
    }
    class u {
      constructor() {
        this.promise = new Promise((e, t) => {
          (this.resolve = e), (this.reject = t);
        });
      }
    }
    function f(e, t) {
      t = t();
      return e.waitUntil(t), t;
    }
    async function p(e, s) {
      let n = null;
      if ((n = e.url ? new URL(e.url).origin : n) !== self.location.origin)
        throw new t("cross-origin-copy-response", { origin: n });
      var e = e.clone(),
        r = {
          headers: new Headers(e.headers),
          status: e.status,
          statusText: e.statusText,
        },
        s = s ? s(r) : r,
        r = (function () {
          if (void 0 === h) {
            var t = new Response("");
            if ("body" in t)
              try {
                new Response(t.body), (h = !0);
              } catch (e) {
                h = !1;
              }
            h = !1;
          }
          return h;
        })()
          ? e.body
          : await e.blob();
      return new Response(r, s);
    }
    const g = (e, t) => t.some((t) => e instanceof t);
    let w, m;
    const y = new WeakMap(),
      _ = new WeakMap(),
      v = new WeakMap(),
      b = new WeakMap(),
      R = new WeakMap();
    let x = {
      get(e, t, s) {
        if (e instanceof IDBTransaction) {
          if ("done" === t) return _.get(e);
          if ("objectStoreNames" === t) return e.objectStoreNames || v.get(e);
          if ("store" === t)
            return s.objectStoreNames[1]
              ? void 0
              : s.objectStore(s.objectStoreNames[0]);
        }
        return E(e[t]);
      },
      set: (e, t, s) => ((e[t] = s), !0),
      has: (e, t) =>
        (e instanceof IDBTransaction && ("done" === t || "store" === t)) ||
        t in e,
    };
    function L(e) {
      return "function" == typeof e
        ? (function (e) {
            return e !== IDBDatabase.prototype.transaction ||
              "objectStoreNames" in IDBTransaction.prototype
              ? (m = m || [
                  IDBCursor.prototype.advance,
                  IDBCursor.prototype.continue,
                  IDBCursor.prototype.continuePrimaryKey,
                ]).includes(e)
                ? function () {
                    for (
                      var t = arguments.length, s = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      s[n] = arguments[n];
                    return e.apply(q(this), s), E(y.get(this));
                  }
                : function () {
                    for (
                      var t = arguments.length, s = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      s[n] = arguments[n];
                    return E(e.apply(q(this), s));
                  }
              : function (t) {
                  for (
                    var s = arguments.length,
                      n = new Array(1 < s ? s - 1 : 0),
                      a = 1;
                    a < s;
                    a++
                  )
                    n[a - 1] = arguments[a];
                  var r = e.call(q(this), t, ...n);
                  return v.set(r, t.sort ? t.sort() : [t]), E(r);
                };
          })(e)
        : (e instanceof IDBTransaction &&
            (function (e) {
              var t;
              _.has(e) ||
                ((t = new Promise((t, s) => {
                  const n = () => {
                      e.removeEventListener("complete", a),
                        e.removeEventListener("error", r),
                        e.removeEventListener("abort", r);
                    },
                    a = () => {
                      t(), n();
                    },
                    r = () => {
                      s(
                        e.error || new DOMException("AbortError", "AbortError")
                      ),
                        n();
                    };
                  e.addEventListener("complete", a),
                    e.addEventListener("error", r),
                    e.addEventListener("abort", r);
                })),
                _.set(e, t));
            })(e),
          g(
            e,
            (w = w || [
              IDBDatabase,
              IDBObjectStore,
              IDBIndex,
              IDBCursor,
              IDBTransaction,
            ])
          )
            ? new Proxy(e, x)
            : e);
    }
    function E(e) {
      var t;
      return e instanceof IDBRequest
        ? (function (e) {
            var t = new Promise((t, s) => {
              const n = () => {
                  e.removeEventListener("success", a),
                    e.removeEventListener("error", r);
                },
                a = () => {
                  t(E(e.result)), n();
                },
                r = () => {
                  s(e.error), n();
                };
              e.addEventListener("success", a), e.addEventListener("error", r);
            });
            return (
              t
                .then((t) => {
                  t instanceof IDBCursor && y.set(t, e);
                })
                .catch(() => {}),
              R.set(t, e),
              t
            );
          })(e)
        : b.has(e)
        ? b.get(e)
        : ((t = L(e)) !== e && (b.set(e, t), R.set(t, e)), t);
    }
    const q = (e) => R.get(e),
      D = ["get", "getKey", "getAll", "getAllKeys", "count"],
      U = ["put", "add", "delete", "clear"],
      T = new Map();
    function k(e, t) {
      if (e instanceof IDBDatabase && !(t in e) && "string" == typeof t) {
        if (T.get(t)) return T.get(t);
        const s = t.replace(/FromIndex$/, ""),
          n = t !== s,
          a = U.includes(s);
        return s in (n ? IDBIndex : IDBObjectStore).prototype &&
          (a || D.includes(s))
          ? ((e = async function (e) {
              e = this.transaction(e, a ? "readwrite" : "readonly");
              let r = e.store;
              for (
                var i = arguments.length,
                  o = new Array(1 < i ? i - 1 : 0),
                  c = 1;
                c < i;
                c++
              )
                o[c - 1] = arguments[c];
              return (
                n && (r = r.index(o.shift())),
                (await Promise.all([r[s](...o), a && e.done]))[0]
              );
            }),
            T.set(t, e),
            e)
          : void 0;
      }
    }
    (x = ((e) => ({
      ...e,
      get: (t, s, n) => k(t, s) || e.get(t, s, n),
      has: (t, s) => !!k(t, s) || e.has(t, s),
    }))(x)),
      s(190);
    const N = "cache-entries",
      I = (e) => {
        e = new URL(e, location.href);
        return (e.hash = ""), e.href;
      };
    class K {
      constructor(e) {
        (this._db = null), (this._cacheName = e);
      }
      _upgradeDb(e) {
        e = e.createObjectStore(N, { keyPath: "id" });
        e.createIndex("cacheName", "cacheName", { unique: !1 }),
          e.createIndex("timestamp", "timestamp", { unique: !1 });
      }
      _upgradeDbAndDeleteOldDbs(e) {
        this._upgradeDb(e),
          this._cacheName &&
            (function (e, argument_1) {
              let t = (
                1 < arguments.length && void 0 !== argument_1 ? argument_1 : {}
              )["blocked"];
              argument_1 = indexedDB.deleteDatabase(e);
              t &&
                argument_1.addEventListener("blocked", (e) =>
                  t(e.oldVersion, e)
                ),
                E(argument_1).then(() => {});
            })(this._cacheName);
      }
      async setTimestamp(e, t) {
        (t = {
          url: (e = I(e)),
          timestamp: t,
          cacheName: this._cacheName,
          id: this._getId(e),
        }),
          (e = (await this.getDb()).transaction(N, "readwrite", {
            durability: "relaxed",
          }));
        await e.store.put(t), await e.done;
      }
      async getTimestamp(e) {
        e = await (await this.getDb()).get(N, this._getId(e));
        return null == e ? void 0 : e.timestamp;
      }
      async expireEntries(e, t) {
        const s = await this.getDb();
        let n = await s
          .transaction(N)
          .store.index("timestamp")
          .openCursor(null, "prev");
        var a = [];
        let r = 0;
        for (; n; ) {
          const s = n.value;
          s.cacheName === this._cacheName &&
            ((e && s.timestamp < e) || (t && r >= t) ? a.push(n.value) : r++),
            (n = await n.continue());
        }
        var i = [];
        for (const o of a) await s.delete(N, o.id), i.push(o.url);
        return i;
      }
      _getId(e) {
        return this._cacheName + "|" + I(e);
      }
      async getDb() {
        return (
          this._db ||
            (this._db = await (function (e, t, argument_2) {
              let {
                blocked: s,
                upgrade: n,
                blocking: a,
                terminated: r,
              } = 2 < arguments.length && void 0 !== argument_2
                ? argument_2
                : {};
              const i = indexedDB.open("workbox-expiration", 1),
                o = E(i);
              return (
                n &&
                  i.addEventListener("upgradeneeded", (e) => {
                    n(
                      E(i.result),
                      e.oldVersion,
                      e.newVersion,
                      E(i.transaction),
                      e
                    );
                  }),
                s &&
                  i.addEventListener("blocked", (e) =>
                    s(e.oldVersion, e.newVersion, e)
                  ),
                o
                  .then((e) => {
                    r && e.addEventListener("close", () => r()),
                      a &&
                        e.addEventListener("versionchange", (e) =>
                          a(e.oldVersion, e.newVersion, e)
                        );
                  })
                  .catch(() => {}),
                o
              );
            })("workbox-expiration", 1, {
              upgrade: this._upgradeDbAndDeleteOldDbs.bind(this),
            })),
          this._db
        );
      }
    }
    class M {
      constructor(e) {
        var t =
          1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
        (this._isRunning = !1),
          (this._rerunRequested = !1),
          (this._maxEntries = t.maxEntries),
          (this._maxAgeSeconds = t.maxAgeSeconds),
          (this._matchOptions = t.matchOptions),
          (this._cacheName = e),
          (this._timestampModel = new K(e));
      }
      async expireEntries() {
        if (this._isRunning) this._rerunRequested = !0;
        else {
          this._isRunning = !0;
          var e = this._maxAgeSeconds
              ? Date.now() - 1e3 * this._maxAgeSeconds
              : 0,
            e = await this._timestampModel.expireEntries(e, this._maxEntries),
            s = await self.caches.open(this._cacheName);
          for (const n of e) await s.delete(n, this._matchOptions);
          (this._isRunning = !1),
            this._rerunRequested &&
              ((this._rerunRequested = !1), l(this.expireEntries()));
        }
      }
      async updateTimestamp(e) {
        await this._timestampModel.setTimestamp(e, Date.now());
      }
      async isURLExpired(e) {
        var s;
        return (
          !!this._maxAgeSeconds &&
          ((e = await this._timestampModel.getTimestamp(e)),
          (s = Date.now() - 1e3 * this._maxAgeSeconds),
          void 0 === e || e < s)
        );
      }
      async delete() {
        (this._rerunRequested = !1),
          await this._timestampModel.expireEntries(1 / 0);
      }
    }
    s(437);
    class P {
      constructor() {
        (this.updatedURLs = []),
          (this.notUpdatedURLs = []),
          (this.handlerWillStart = async (e) => {
            var { request: e, state: s } = e;
            s && (s.originalRequest = e);
          }),
          (this.cachedResponseWillBeUsed = async (e) => {
            var { event: e, state: s, cachedResponse: n } = e;
            if (
              "install" === e.type &&
              s &&
              s.originalRequest &&
              s.originalRequest instanceof Request
            ) {
              const e = s.originalRequest.url;
              (n ? this.notUpdatedURLs : this.updatedURLs).push(e);
            }
            return n;
          });
      }
    }
    class S {
      constructor(e) {
        e = e.precacheController;
        (this.cacheKeyWillBeUsed = async (e) => {
          var { request: e, params: s } = e,
            s =
              (null == s ? void 0 : s.cacheKey) ||
              this._precacheController.getCacheKeyForURL(e.url);
          return s ? new Request(s, { headers: e.headers }) : e;
        }),
          (this._precacheController = e);
      }
    }
    function O(e) {
      return "string" == typeof e ? new Request(e) : e;
    }
    s(833);
    class W {
      constructor(e, t) {
        (this._cacheKeys = {}),
          Object.assign(this, t),
          (this.event = t.event),
          (this._strategy = e),
          (this._handlerDeferred = new u()),
          (this._extendLifetimePromises = []),
          (this._plugins = [...e.plugins]),
          (this._pluginStateMap = new Map());
        for (const s of this._plugins) this._pluginStateMap.set(s, {});
        this.event.waitUntil(this._handlerDeferred.promise);
      }
      async fetch(e) {
        var s = this["event"];
        let n = O(e);
        if (
          "navigate" === n.mode &&
          s instanceof FetchEvent &&
          s.preloadResponse
        ) {
          const e = await s.preloadResponse;
          if (e) return e;
        }
        var a = this.hasCallback("fetchDidFail") ? n.clone() : null;
        try {
          for (const e of this.iterateCallbacks("requestWillFetch"))
            n = await e({ request: n.clone(), event: s });
        } catch (i) {
          if (i instanceof Error)
            throw new t("plugin-error-request-will-fetch", {
              thrownErrorMessage: i.message,
            });
        }
        var r = n.clone();
        try {
          let e;
          e = await fetch(
            n,
            "navigate" === n.mode ? void 0 : this._strategy.fetchOptions
          );
          for (const t of this.iterateCallbacks("fetchDidSucceed"))
            e = await t({ event: s, request: r, response: e });
          return e;
        } catch (o) {
          throw (
            (a &&
              (await this.runCallbacks("fetchDidFail", {
                error: o,
                event: s,
                originalRequest: a.clone(),
                request: r.clone(),
              })),
            o)
          );
        }
      }
      async fetchAndCachePut(e) {
        var t = await this.fetch(e),
          s = t.clone();
        return this.waitUntil(this.cachePut(e, s)), t;
      }
      async cacheMatch(e) {
        e = O(e);
        let s;
        var { cacheName: n, matchOptions: a } = this._strategy,
          r = await this.getCacheKey(e, "read"),
          e = Object.assign(Object.assign({}, a), { cacheName: n });
        s = await caches.match(r, e);
        for (const o of this.iterateCallbacks("cachedResponseWillBeUsed"))
          s =
            (await o({
              cacheName: n,
              matchOptions: a,
              cachedResponse: s,
              request: r,
              event: this.event,
            })) || void 0;
        return s;
      }
      async cachePut(e, s) {
        var e = O(e),
          i =
            (await new Promise((e) => setTimeout(e, 0)),
            await this.getCacheKey(e, "write"));
        if (!s)
          throw new t("cache-put-with-no-response", {
            url: ((e) =>
              new URL(String(e), location.href).href.replace(
                new RegExp("^".concat(location.origin)),
                ""
              ))(i.url),
          });
        var o = await this._ensureResponseSafeToCache(s);
        if (!o) return !1;
        var { cacheName: h, matchOptions: e } = this._strategy,
          s = await self.caches.open(h),
          f = this.hasCallback("cacheDidUpdate"),
          p = f
            ? await (async function (e, t, s, n) {
                var a = c(t.url, s);
                if (t.url === a) return e.match(t, n);
                var r = Object.assign(Object.assign({}, n), {
                  ignoreSearch: !0,
                });
                for (const o of await e.keys(t, r))
                  if (a === c(o.url, s)) return e.match(o, n);
              })(s, i.clone(), ["__WB_REVISION__"], e)
            : null;
        try {
          await s.put(i, f ? o.clone() : o);
        } catch (g) {
          if (g instanceof Error)
            throw (
              ("QuotaExceededError" === g.name &&
                (await (async function () {
                  for (const e of n) await e();
                })()),
              g)
            );
        }
        for (const t of this.iterateCallbacks("cacheDidUpdate"))
          await t({
            cacheName: h,
            oldResponse: p,
            newResponse: o.clone(),
            request: i,
            event: this.event,
          });
        return !0;
      }
      async getCacheKey(e, t) {
        var s = "".concat(e.url, " | ").concat(t);
        if (!this._cacheKeys[s]) {
          let n = e;
          for (const e of this.iterateCallbacks("cacheKeyWillBeUsed"))
            n = O(
              await e({
                mode: t,
                request: n,
                event: this.event,
                params: this.params,
              })
            );
          this._cacheKeys[s] = n;
        }
        return this._cacheKeys[s];
      }
      hasCallback(e) {
        for (const t of this._strategy.plugins) if (e in t) return !0;
        return !1;
      }
      async runCallbacks(e, t) {
        for (const s of this.iterateCallbacks(e)) await s(t);
      }
      *iterateCallbacks(e) {
        for (const t of this._strategy.plugins)
          if ("function" == typeof t[e]) {
            const s = this._pluginStateMap.get(t);
            yield (n) => {
              n = Object.assign(Object.assign({}, n), { state: s });
              return t[e](n);
            };
          }
      }
      waitUntil(e) {
        return this._extendLifetimePromises.push(e), e;
      }
      async doneWaiting() {
        for (var e; (e = this._extendLifetimePromises.shift()); ) await e;
      }
      destroy() {
        this._handlerDeferred.resolve(null);
      }
      async _ensureResponseSafeToCache(e) {
        let t = e,
          s = !1;
        for (const n of this.iterateCallbacks("cacheWillUpdate"))
          if (
            ((t =
              (await n({
                request: this.request,
                response: t,
                event: this.event,
              })) || void 0),
            (s = !0),
            !t)
          )
            break;
        return s || (t && 200 !== t.status && (t = void 0)), t;
      }
    }
    class B {
      constructor() {
        var e =
          0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        (this.cacheName = o(e.cacheName)),
          (this.plugins = e.plugins || []),
          (this.fetchOptions = e.fetchOptions),
          (this.matchOptions = e.matchOptions);
      }
      handle(e) {
        var [e] = this.handleAll(e);
        return e;
      }
      handleAll(e) {
        var t = (e =
            e instanceof FetchEvent ? { event: e, request: e.request } : e)
            .event,
          s = "string" == typeof e.request ? new Request(e.request) : e.request,
          e = "params" in e ? e.params : void 0,
          e = new W(this, { event: t, request: s, params: e }),
          r = this._getResponse(e, s, t);
        return [r, this._awaitComplete(r, e, s, t)];
      }
      async _getResponse(e, s, n) {
        let a;
        await e.runCallbacks("handlerWillStart", { event: n, request: s });
        try {
          if (!(a = await this._handle(s, e)) || "error" === a.type)
            throw new t("no-response", { url: s.url });
        } catch (r) {
          if (r instanceof Error)
            for (const t of e.iterateCallbacks("handlerDidError"))
              if (((a = await t({ error: r, event: n, request: s })), a)) break;
          if (!a) throw r;
        }
        for (const t of e.iterateCallbacks("handlerWillRespond"))
          a = await t({ event: n, request: s, response: a });
        return a;
      }
      async _awaitComplete(e, t, s, n) {
        let a, r;
        try {
          a = await e;
        } catch (r) {}
        try {
          await t.runCallbacks("handlerDidRespond", {
            event: n,
            request: s,
            response: a,
          }),
            await t.doneWaiting();
        } catch (i) {
          i instanceof Error && (r = i);
        }
        if (
          (await t.runCallbacks("handlerDidComplete", {
            event: n,
            request: s,
            response: a,
            error: r,
          }),
          t.destroy(),
          r)
        )
          throw r;
      }
    }
    class j extends B {
      constructor() {
        var e =
          0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        (e.cacheName = i(e.cacheName)),
          super(e),
          (this._fallbackToNetwork = !1 !== e.fallbackToNetwork),
          this.plugins.push(j.copyRedirectedCacheableResponsesPlugin);
      }
      async _handle(e, t) {
        return (
          (await t.cacheMatch(e)) ||
          (t.event && "install" === t.event.type
            ? await this._handleInstall(e, t)
            : await this._handleFetch(e, t))
        );
      }
      async _handleFetch(e, s) {
        var a = s.params || {};
        if (!this._fallbackToNetwork)
          throw new t("missing-precache-entry", {
            cacheName: this.cacheName,
            url: e.url,
          });
        {
          const t = a.integrity,
            r = e.integrity,
            i = !r || r === t;
          (a = await s.fetch(
            new Request(e, {
              integrity: "no-cors" !== e.mode ? r || t : void 0,
            })
          )),
            t &&
              i &&
              "no-cors" !== e.mode &&
              (this._useDefaultCacheabilityPluginIfNeeded(),
              await s.cachePut(e, a.clone()));
        }
        return a;
      }
      async _handleInstall(e, s) {
        this._useDefaultCacheabilityPluginIfNeeded();
        var n = await s.fetch(e);
        if (await s.cachePut(e, n.clone())) return n;
        throw new t("bad-precaching-response", {
          url: e.url,
          status: n.status,
        });
      }
      _useDefaultCacheabilityPluginIfNeeded() {
        let e = null,
          t = 0;
        for (var [s, n] of this.plugins.entries())
          n !== j.copyRedirectedCacheableResponsesPlugin &&
            (n === j.defaultPrecacheCacheabilityPlugin && (e = s),
            n.cacheWillUpdate) &&
            t++;
        0 === t
          ? this.plugins.push(j.defaultPrecacheCacheabilityPlugin)
          : 1 < t && null !== e && this.plugins.splice(e, 1);
      }
    }
    (j.defaultPrecacheCacheabilityPlugin = {
      async cacheWillUpdate(e) {
        e = e.response;
        return !e || 400 <= e.status ? null : e;
      },
    }),
      (j.copyRedirectedCacheableResponsesPlugin = {
        async cacheWillUpdate(e) {
          e = e.response;
          return e.redirected ? await p(e) : e;
        },
      });
    class F {
      constructor() {
        var {
          cacheName: e,
          plugins: t = [],
          fallbackToNetwork: s = !0,
        } = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        (this._urlsToCacheKeys = new Map()),
          (this._urlsToCacheModes = new Map()),
          (this._cacheKeysToIntegrities = new Map()),
          (this._strategy = new j({
            cacheName: i(e),
            plugins: [...t, new S({ precacheController: this })],
            fallbackToNetwork: s,
          })),
          (this.install = this.install.bind(this)),
          (this.activate = this.activate.bind(this));
      }
      get strategy() {
        return this._strategy;
      }
      precache(e) {
        this.addToCacheList(e),
          this._installAndActiveListenersAdded ||
            (self.addEventListener("install", this.install),
            self.addEventListener("activate", this.activate),
            (this._installAndActiveListenersAdded = !0));
      }
      addToCacheList(e) {
        var s = [];
        for (const n of e) {
          "string" == typeof n
            ? s.push(n)
            : n && void 0 === n.revision && s.push(n.url);
          const { cacheKey: e, url: a } = (function (e) {
              if (!e)
                throw new t("add-to-cache-list-unexpected-type", { entry: e });
              if ("string" == typeof e) {
                const t = new URL(e, location.href);
                return { cacheKey: t.href, url: t.href };
              }
              var r,
                { revision: s, url: n } = e;
              if (!n)
                throw new t("add-to-cache-list-unexpected-type", { entry: e });
              if (s)
                return (
                  (e = new URL(n, location.href)),
                  (r = new URL(n, location.href)),
                  e.searchParams.set("__WB_REVISION__", s),
                  { cacheKey: e.href, url: r.href }
                );
              {
                const e = new URL(n, location.href);
                return { cacheKey: e.href, url: e.href };
              }
            })(n),
            r = "string" != typeof n && n.revision ? "reload" : "default";
          if (
            this._urlsToCacheKeys.has(a) &&
            this._urlsToCacheKeys.get(a) !== e
          )
            throw new t("add-to-cache-list-conflicting-entries", {
              firstEntry: this._urlsToCacheKeys.get(a),
              secondEntry: e,
            });
          if ("string" != typeof n && n.integrity) {
            if (
              this._cacheKeysToIntegrities.has(e) &&
              this._cacheKeysToIntegrities.get(e) !== n.integrity
            )
              throw new t("add-to-cache-list-conflicting-integrities", {
                url: a,
              });
            this._cacheKeysToIntegrities.set(e, n.integrity);
          }
          if (
            (this._urlsToCacheKeys.set(a, e),
            this._urlsToCacheModes.set(a, r),
            0 < s.length)
          ) {
            const e =
              "Workbox is precaching URLs without revision " +
              "info: ".concat(s.join(", "), "\nThis is generally NOT safe. ") +
              "Learn more at https://bit.ly/wb-precache";
            console.warn(e);
          }
        }
      }
      install(e) {
        return f(e, async () => {
          const t = new P();
          this.strategy.plugins.push(t);
          for (var [a, r] of this._urlsToCacheKeys) {
            const t = this._cacheKeysToIntegrities.get(r),
              s = this._urlsToCacheModes.get(a),
              n = new Request(a, {
                integrity: t,
                cache: s,
                credentials: "same-origin",
              });
            await Promise.all(
              this.strategy.handleAll({
                params: { cacheKey: r },
                request: n,
                event: e,
              })
            );
          }
          const { updatedURLs: s, notUpdatedURLs: n } = t;
          return { updatedURLs: s, notUpdatedURLs: n };
        });
      }
      activate(e) {
        return f(e, async () => {
          var e = await self.caches.open(this.strategy.cacheName),
            t = await e.keys(),
            s = new Set(this._urlsToCacheKeys.values()),
            n = [];
          for (const a of t) s.has(a.url) || (await e.delete(a), n.push(a.url));
          return { deletedURLs: n };
        });
      }
      getURLsToCacheKeys() {
        return this._urlsToCacheKeys;
      }
      getCachedURLs() {
        return [...this._urlsToCacheKeys.keys()];
      }
      getCacheKeyForURL(e) {
        e = new URL(e, location.href);
        return this._urlsToCacheKeys.get(e.href);
      }
      getIntegrityForCacheKey(e) {
        return this._cacheKeysToIntegrities.get(e);
      }
      async matchPrecache(e) {
        (e = e instanceof Request ? e.url : e), (e = this.getCacheKeyForURL(e));
        if (e)
          return (await self.caches.open(this.strategy.cacheName)).match(e);
      }
      createHandlerBoundToURL(e) {
        const s = this.getCacheKeyForURL(e);
        if (s)
          return (t) => (
            (t.request = new Request(e)),
            (t.params = Object.assign({ cacheKey: s }, t.params)),
            this.strategy.handle(t)
          );
        throw new t("non-precached-url", { url: e });
      }
    }
    let H;
    const V = () => (H = H || new F()),
      G = (s(185), (e) => (e && "object" == typeof e ? e : { handle: e }));
    class $ {
      constructor(e, t) {
        var s =
          2 < arguments.length && void 0 !== arguments[2]
            ? arguments[2]
            : "GET";
        (this.handler = G(t)), (this.match = e), (this.method = s);
      }
      setCatchHandler(e) {
        this.catchHandler = G(e);
      }
    }
    class Q extends $ {
      constructor(e, t, s) {
        super(
          (t) => {
            var t = t["url"],
              n = e.exec(t.href);
            if (n && (t.origin === location.origin || 0 === n.index))
              return n.slice(1);
          },
          t,
          s
        );
      }
    }
    class J {
      constructor() {
        (this._routes = new Map()), (this._defaultHandlerMap = new Map());
      }
      get routes() {
        return this._routes;
      }
      addFetchListener() {
        self.addEventListener("fetch", (e) => {
          var t = e["request"],
            t = this.handleRequest({ request: t, event: e });
          t && e.respondWith(t);
        });
      }
      addCacheListener() {
        self.addEventListener("message", (e) => {
          var t;
          e.data &&
            "CACHE_URLS" === e.data.type &&
            ((t = e.data["payload"]),
            (t = Promise.all(
              t.urlsToCache.map((t) => {
                "string" == typeof t && (t = [t]);
                t = new Request(...t);
                return this.handleRequest({ request: t, event: e });
              })
            )),
            e.waitUntil(t),
            e.ports) &&
            e.ports[0] &&
            t.then(() => e.ports[0].postMessage(!0));
        });
      }
      handleRequest(e) {
        let { request: t, event: s } = e;
        const n = new URL(t.url, location.href);
        if (n.protocol.startsWith("http")) {
          const a = n.origin === location.origin,
            { params: r, route: i } = this.findMatchingRoute({
              event: s,
              request: t,
              sameOrigin: a,
              url: n,
            });
          let o = i && i.handler;
          e = t.method;
          if (
            (o =
              !o && this._defaultHandlerMap.has(e)
                ? this._defaultHandlerMap.get(e)
                : o)
          ) {
            let h;
            try {
              h = o.handle({ url: n, request: t, event: s, params: r });
            } catch (u) {
              h = Promise.reject(u);
            }
            const l = i && i.catchHandler;
            return (h =
              h instanceof Promise && (this._catchHandler || l)
                ? h.catch(async (e) => {
                    if (l)
                      try {
                        return await l.handle({
                          url: n,
                          request: t,
                          event: s,
                          params: r,
                        });
                      } catch (a) {
                        a instanceof Error && (e = a);
                      }
                    if (this._catchHandler)
                      return this._catchHandler.handle({
                        url: n,
                        request: t,
                        event: s,
                      });
                    throw e;
                  })
                : h);
          }
        }
      }
      findMatchingRoute(e) {
        var { url: t, sameOrigin: s, request: n, event: a } = e;
        const r = this._routes.get(n.method) || [];
        for (const i of r) {
          let e;
          const r = i.match({ url: t, sameOrigin: s, request: n, event: a });
          if (r)
            return (
              (e = r),
              ((Array.isArray(e) && 0 === e.length) ||
                (r.constructor === Object && 0 === Object.keys(r).length) ||
                "boolean" == typeof r) &&
                (e = void 0),
              { route: i, params: e }
            );
        }
        return {};
      }
      setDefaultHandler(e) {
        this._defaultHandlerMap.set(
          1 < arguments.length && void 0 !== arguments[1]
            ? arguments[1]
            : "GET",
          G(e)
        );
      }
      setCatchHandler(e) {
        this._catchHandler = G(e);
      }
      registerRoute(e) {
        this._routes.has(e.method) || this._routes.set(e.method, []),
          this._routes.get(e.method).push(e);
      }
      unregisterRoute(e) {
        if (!this._routes.has(e.method))
          throw new t("unregister-route-but-not-found-with-method", {
            method: e.method,
          });
        var s = this._routes.get(e.method).indexOf(e);
        if (!(-1 < s)) throw new t("unregister-route-route-not-registered");
        this._routes.get(e.method).splice(s, 1);
      }
    }
    let z;
    function Y(e, s, n) {
      let a;
      if ("string" == typeof e) {
        const t = new URL(e, location.href);
        a = new $(
          (e) => {
            e = e.url;
            return e.href === t.href;
          },
          s,
          n
        );
      } else if (e instanceof RegExp) a = new Q(e, s, n);
      else if ("function" == typeof e) a = new $(e, s, n);
      else {
        if (!(e instanceof $))
          throw new t("unsupported-route-type", {
            moduleName: "workbox-routing",
            funcName: "registerRoute",
            paramName: "capture",
          });
        a = e;
      }
      z || ((z = new J()).addFetchListener(), z.addCacheListener()),
        z.registerRoute(a),
        a;
    }
    class Z extends $ {
      constructor(e, t) {
        super((s) => {
          var s = s["request"],
            a = e.getURLsToCacheKeys();
          for (const r of (function (e, argument_1) {
            let {
              ignoreURLParametersMatching: t = [/^utm_/, /^fbclid$/],
              directoryIndex: s = "index.html",
              cleanURLs: n = !0,
              urlManipulation: a,
            } = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : {};
            return (function* () {
              var r = new URL(e, location.href),
                i =
                  ((r.hash = ""),
                  yield r.href,
                  (function (e, argument_1) {
                    var t =
                      1 < arguments.length && void 0 !== argument_1
                        ? argument_1
                        : [];
                    for (const s of [...e.searchParams.keys()])
                      t.some((e) => e.test(s)) && e.searchParams.delete(s);
                    return e;
                  })(r, t));
              if ((yield i.href, s && i.pathname.endsWith("/"))) {
                const e = new URL(i.href);
                (e.pathname += s), yield e.href;
              }
              if (n) {
                const e = new URL(i.href);
                (e.pathname += ".html"), yield e.href;
              }
              if (a) {
                const e = a({ url: r });
                for (const t of e) yield t.href;
              }
            })();
          })(s.url, t)) {
            const t = a.get(r);
            if (t)
              return { cacheKey: t, integrity: e.getIntegrityForCacheKey(t) };
          }
        }, e.strategy);
      }
    }
    const ee = {
      cacheWillUpdate: async (e) => {
        e = e.response;
        return 200 === e.status || 0 === e.status ? e : null;
      },
    };
    self.addEventListener("activate", () => self.clients.claim()),
      V().precache([
        {
          revision: "9fb0aac970c98e6de3fe303fcdce0fac",
          url: "/meet/index.html",
        },
        { revision: null, url: "/meet/static/css/main.edb5de07.css" },
        { revision: null, url: "/meet/static/js/787.0f140951.chunk.js" },
        { revision: null, url: "/meet/static/js/main.44df601c.js" },
      ]),
      (function () {
        var t = V();
        Y(new Z(t, void 0));
      })();
    const se = new RegExp("/[^/?]+\\.[^/]+$");
    Y((e) => {
      var { request: e, url: s } = e;
      return (
        "navigate" === e.mode &&
        !s.pathname.startsWith("/_") &&
        !s.pathname.match(se)
      );
    }, V().createHandlerBoundToURL("/meet/index.html")),
      Y(
        (e) => {
          e = e.url;
          return (
            e.origin === self.location.origin && e.pathname.endsWith(".png")
          );
        },
        new (class extends B {
          constructor() {
            super(
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : {}
            ),
              this.plugins.some((e) => "cacheWillUpdate" in e) ||
                this.plugins.unshift(ee);
          }
          async _handle(e, s) {
            var n = s.fetchAndCachePut(e).catch(() => {});
            s.waitUntil(n);
            let a,
              r = await s.cacheMatch(e);
            if (!r)
              try {
                r = await n;
              } catch (i) {
                i instanceof Error && (a = i);
              }
            if (r) return r;
            throw new t("no-response", { url: e.url, error: a });
          }
        })({
          cacheName: "images",
          plugins: [
            new (class {
              constructor() {
                var e =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
                (this.cachedResponseWillBeUsed = async (e) => {
                  var {
                    event: e,
                    request: s,
                    cacheName: n,
                    cachedResponse: a,
                  } = e;
                  if (!a) return null;
                  var r = this._isResponseDateFresh(a),
                    n = this._getCacheExpiration(n),
                    n = (l(n.expireEntries()), n.updateTimestamp(s.url));
                  if (e)
                    try {
                      e.waitUntil(n);
                    } catch (c) {}
                  return r ? a : null;
                }),
                  (this.cacheDidUpdate = async (e) => {
                    var { cacheName: e, request: s } = e,
                      e = this._getCacheExpiration(e);
                    await e.updateTimestamp(s.url), await e.expireEntries();
                  }),
                  (this._config = e),
                  (this._maxAgeSeconds = e.maxAgeSeconds),
                  (this._cacheExpirations = new Map()),
                  e.purgeOnQuotaError &&
                    (function (e) {
                      n.add(e);
                    })(() => this.deleteCacheAndMetadata());
              }
              _getCacheExpiration(e) {
                if (e === o()) throw new t("expire-custom-caches-only");
                let s = this._cacheExpirations.get(e);
                return (
                  s ||
                    ((s = new M(e, this._config)),
                    this._cacheExpirations.set(e, s)),
                  s
                );
              }
              _isResponseDateFresh(e) {
                return (
                  !this._maxAgeSeconds ||
                  null === (e = this._getDateHeaderTimestamp(e)) ||
                  e >= Date.now() - 1e3 * this._maxAgeSeconds
                );
              }
              _getDateHeaderTimestamp(e) {
                return !e.headers.has("date") ||
                  ((e = e.headers.get("date")),
                  (e = new Date(e).getTime()),
                  isNaN(e))
                  ? null
                  : e;
              }
              async deleteCacheAndMetadata() {
                for (var [e, t] of this._cacheExpirations)
                  await self.caches.delete(e), await t.delete();
                this._cacheExpirations = new Map();
              }
            })({ maxEntries: 50 }),
          ],
        })
      ),
      self.addEventListener("message", (e) => {
        e.data && "SKIP_WAITING" === e.data.type && self.skipWaiting();
      });
  })();
})();
